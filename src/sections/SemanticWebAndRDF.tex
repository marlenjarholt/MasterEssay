%!TEX root = ../master.tex
\section{Semantic Web and RDF}
In general, the semantic web and semantic web technology is an extension of the World Wide Web. However, semantic web and semantic web technology do not refer to one concrete extension. The goal for the semantic web is to make the data that is accessible on the Internet readable for a machine. The semantic web primarily utilises \emph{linked data} to make the data more readable for machines. Where data refers to data and metadata, meaning that, in structure, data and metadata are treated equally.  Linked data is built up by using identifiers that point to web addresses where more information can be found. These identifiers have connections to other identifiers, where the connections give information on the relationship the first identifiers have to the second one. The result will then resemble a directed graph. The connected data needs some formal semantic to work, such as RDF, RDFS, OWL.  These components structure the linked data by providing a formal description of terms, relationships, and concept in the knowledge domain. In semantic web and computer science in general, we would call this an \emph{ontology}. By definition, an \emph{ontology} is knowledge we have about a given domain that is machine-processable and with a formally defined meaning.

\begin{figure}
    \centering
    \includegraphics[scale=0.2]{SWStack.png}
    \caption{The semantic web stack src: IN3060 foiler uke 2}
    \label{fig:SW stack}
\end{figure}


\subsection{RDF}
RDF stands for \emph{Resource Description Framework}, and it is a language for formally describing structure data. RDF is the general method used in the semantic web to describe information in a web resource,  which describes a collection of triples. As the name triple insinuates, a triple contains three elements, or more formally, three resources. These three resources have unique names and meaning depending on their placement in the triple. Firstly the subject, secondly the predicate and lastly, the object. The predicate describes a relationship that the subject has to the object. Usually, one can describe a collection of triples as a graph where the subjects and objects are nodes, and the predicates are a directed edge from a subject to an object. The predicate then describes the subjects' relation to the object. However, RDF can represent a structure that we ordinarily would not describe as a graph. Due to there are no restrictions in RDF for a resource only being a subject/object or a predicate. In terms of results, it is possible to have an element in the graph representing a node and an edge.  An example of a triple is Sebastian hasFather Thommas, where Sebastian is the object, hasFather is the predicate, and Thommas is the object. RDF have numerous serializations; we will use Turtle for the examples. 

\para
To distinguish between the different resources in an RDF graph, we need to identify the different resources uniquely. Therefore, RDF uses \emph{Uniform Resource Locator} (URI), where every URI represent a unique resource. Every URL is a URI ($URL\subseteq URI$). However, not all URIs are URL ($URL\nsubseteq URI$).  Previously, we had an example triple Sebastian hasFather Thommas. This example needs to use URI since we need to distinguish between the different resource, resulting in the triple $<http://example.org/person/Sebastian> <http://example.org/relation/hasFather> <http://example.org/person/Thommas> .$ . However, it may become time-consuming to write the whole URI for Sebastian every time we want to refer to the Sebastian resource; therefore, we have something called prefix in Turtle. We need to set the prefixes at the start of the Turtle document. Appending $@PREFIX\; ex-p:\; <http://example.org/person/>.$ in the start of the document containing the example triple would result in the possibility to shorten <http://example.org/person/Sebastian> down to ex-p:Sebastian . Adding the prefix $@PREFIX\; ex-r:\; <http://example.org/relation/>.$ will result in the opportunity to shorten the full triple down to $ex-p:Sebastian\; ex-r:hasFather\; ex-p:Thommas\; .$. The examples in this section and the next section will use the following prefixes.

\begin{lstlisting}[frame=single, language=turtle]
@prefix  ex-p:  <http://example.org/person/> . 
@prefix ex-r:  <http://example.org/relation/> . 
@prefix ex-t:  <http://example.org/template/> . 
@prefix xsd: <http://www.w3.org/2001/XMLSchema/#>  . 
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix ottr: <http://ns.ottr.xyz/0.4/> .
@prefix o-rdf: <http://tpl.ottr.xyz/rdf/0.1/> .
\end{lstlisting}

\para
In the previous examples, we have started to make an ontology for families. Sometimes we know something about something without knowing what that thing is. For example, we may know that Sebastian has a father without knowing how the father is. RDF uses \emph{blank nodes} to express that we know something about a resource without knowing the URI of the resource. In the case when we know that Sebastian has a father without knowing how the father is the father is a blank node. Note that a blank node only can occur in the subject or object position, not in the predicate position. To model that Sebastian has a father we can write either $ex-p:Sebastian\; ex-r:hasFather\; \_:b .$ or $ex-p:Sebastian\; ex-r:hasFather\; [\; ]$ , since the syntax for writing an blank node in Turtle is either $\_:<some variable name>$ or $[\; ]$. Since an empty node also can be a subject, we can express things about the resources. Therefore, if we want to model that Sebastian has a father who has a father how is http://example.org/person/Roger we can write $ex-p:Sebastian\; ex-r:hasFather\; [\; ex-r:hasFather\; ex-p:Roger] .$ or $ex-p:Sebastian\; ex-r:hasFather\; \_:father . \\ \_:father \; ex-r:hasFather\; ex-p:Roger .$

\para
RDF also uses \emph{literals}, such as strings and integer. Literals can only be in the object position of the triple. If we want to express that Sebastian has age 21 we can write $ex-p:Sebastian\; ex-r:hasAge\; " 22 " <opp greie> <opp greie> xsd:int.$. In addition, we can add that Sebastian has the name Sebastian in Norweigan and Bastian in English by using \emph{language tags}. Resulting in the triples $ex-p:Sebastian\; ex-r:hasName\; Sebastian@no.$ and $ex-p:Sebastian\; ex-r:hasName\; Bastian@en.$. The graph containing all the triples mention in this section, for now, would look like this:

\begin{lstlisting}[frame=single, language=turtle]
ex-p:Sebastian ex-r:hasFather ex-p:Thommas .
ex-p:Sebastian ex-r:hasFather [ ex-r:hasFather ex-p:Roger] . 
ex-p:Sebastian ex-r:hasAge  "22"^^xsd:int . 
ex-p:Sebastian ex-r:hasName  "Sebastian"@no . 
ex-p:Sebastian ex-r:hasName  "Bastian"@en .
\end{lstlisting}

\para
In addition, to the already mentioned abbreviations, Turtle has some more to make the Turtle file more compact. For instance, if we have the same predicate and subject several times, with different objects, we can write the predicate and subject one time and separate the objects with a , . Furthermore, Turtle also allows us to abbreviate when we use the same subject several times by writing ; at the end of the line instead of . . This gives this turtle file:

\begin{lstlisting}[frame=single, language=turtle]
ex-p:Sebastian ex-r:hasFather ex-p:Thommas, [ ex-r:hasFather ex-p:Roger] ; 
                ex-r:hasAge  "22"^^xsd:int ; 
                ex-r:hasName  "Sebastian"@no, "Bastian"@en .
\end{lstlisting}
\autoref{fig:exampelGraph} is a visual graph of the graph we have now made.

\begin{figure}
    \centering
    \includegraphics[scale=0.2]{exampleGraph.png}
    \caption{The visual graph over the graph made in section 2.1}
    \label{fig:exampelGraph}
\end{figure}

\subsubsection{Lists in RDF}
In RDF, we have two main ways to represent lists, \emph{containers} and \emph{collections}. These two are an abbreviation of two specific ways to link data together using blank nodes.  We usually use lists in RDF when we want to express that a subject has the same relation (predicate) to several objects, such as listing a person's relatives.

\para
Firstly, a container has three different types, namely rdf:Seq (represents an order list), rdf:Bag (representing an unordered set) and rdf:Alt (representing a set of alternatives). A blank node with a rdf:type rdf:type; rdf:Seq, rdf:Bag or rdf:Alt builds up a container. The blank nodes type, as long as it is one of the three types, does not change the structure, only how the different applications display them.  To add nodes to the container, we need to add a predicate,$rdf\_1$ to $rdf\_n$, from the blank node to the member. Where the first element has the predicate $rdf\_1$, and the n-th element has predicate $rdf\_n$. So if we want to add a list to over RDF graph stating all Sebastian ancestors in an unordered set, 
it will look like this\footnote{Note that we have used the abbreviation a for rdf:type}:
\begin{lstlisting}[frame=single, language=turtle]
ex-p:Sebastian ex-r:hasFather ex-p:Thommas, [ ex-r:hasFather ex-p:Roger] ; 
                ex-r:hasAge  "22"^^xsd:int ; 
                ex-r:hasName  "Sebastian"@no, "Bastian"@en ;
                ex-r:ancestor [a rdf:Bag; 
                                rdf:_1 ex-p:Thommas; 
                                rdf:_2 ex-p:Roger].
\end{lstlisting}
Secondly, we can make lists by using collections. The main difference between a container and a collection is that a collection is closed, meaning it is impossible to add new elements after making a list. On the contrary, it is possible to add new elements to a container, as long as we reference the blank node (e.g. \_:list). The reason for collections being closed is that they are built up like a linked list where we connect blank nodes, which links to an element. Collections have two predicates to link the blank nodes and elements together. 

\begin{itemize}
    \item rdf:first: is the predicate linking us to an element
    \item rdf:rest: linking us to the rest of the list
    \item rdf:nil: end of the list
\end{itemize}
\autoref{fig:containerAndCollection} visualises the differences between containers and collections. In Turtle, we can use () as an abbreviation for writing collections where we put the collection elements inside the (). In the general chase, it will look like this $(member_1 \;member_2 .... member_n)$ An RDF graph, which contains all Sebastian's ancestors, using collection will then end up looking like this:

\begin{lstlisting}[frame=single, language=turtle]
ex-p:Sebastian ex-r:hasFather ex-p:Thommas, [ ex-r:hasFather ex-p:Roger] ; 
                ex-r:hasAge  "22"^^xsd:int ; 
                ex-r:hasName  "Sebastian"@no, "Bastian"@en ;
                ex-r:ancestor (ex-p:Thommas ex-p:Roger).
\end{lstlisting}

\begin{figure}
    \centering
    \includegraphics[scale=0.2]{containerAndCollection.png}
    \caption{Shows the difference between a container and a collections in structur}
    \label{fig:containerAndCollection}
\end{figure}

\subsection{OTTR}
\emph{Reasonable Ontology Templates}(OTTR) is a language that represents ontology modelling patterns as parameterised ontologies and is a way to make user-defined abstractions to recurring modelling patterns. OTTR is build up by templates that consist of a head and a body. The head specifies the name of the templates and the template parameters while the body contains the parameterised ontology pattern. OTTR also allow us to specify the types, which we will come back to, and the cardinality of the parameters. There are two types of cardinalities mandatory or optional. Optional is denoted with a ? while mandatory is the default. In addition, a parameter can be non-blank, meaning that it cannot take in a blank node. We can denote a non-blank paramter usingin !. In additin, parameters can specify a default value used whenever the corresponding argument is none. None is a value in the OTTR framework used to represent a missing or no value. \autoref{fig:stOTTERGenralisation} shows a generalisation of OTTR written in the seralisation stOTTR.

\para
In OTTR, we have \emph{instances}, which are how we use a template. Instances contain the name of the template it is using and a list of all the arguments. The list of arguments needs to match the parameters specified in the template.  To build up the parameterised ontology pattern in the body, we use instances of templates and base templates. \emph{Base templates} is a particular type of template that may not contain a pattern. One critical base template is ottr:Triple, representing a single RDF tripel. ottr:Triple takes in three arguments a subject, a predicate and an object, in that particular order. Instances used recursion to expand into RDF graphs, recursively replacing all the instances in the body with the pattern they represent. The recursion stops when it reaches a base template. OTTR has four serialisations representing the templates and the instances, stOTTER, wOTTR, tabOTTR and bOTTR. stOTTER is custom serialisation for OTTR, made to be compact and easy to ready for humans. wOTTR is a serialisation written in RDF and specified by an OWL ontology and uses SHACL to define the grammar. Furthermore, tabOTTR can create instances from spreadsheets, and bOTTR can make mappings over several queryable sources. 

\para
OTTR provides three different \emph{expansion modes} that can it can use on lists.
\begin{itemize}
    \item cross: gives one instance per element in the cross-product
    \item zipMin: makes one instance per element in the smallest list, making n instances, where n is the length of the smallest list, and relating the element on the same index in the lists
    \item zipMax:  almost the same as zipMin, but instead of choosing the smallest list, zipMax makes one instance for every element in the largest list. OTTR will then append none at the end of the smaller lists until they are the same size as the larges. 
\end{itemize}
We can use these expansion mods when making an instance in a template body. OTTR will treat every argument in an instance that has an expansion mode as a list. However, OTTR will only expand the arguments marked with the list expansion, ++, in front of the argument. Additionally, OTTR will treat arguments without a list expansion as a list with one element. Note that the different list expansions behave the same if we only mark one argument with the list expansion. 

\begin{lstlisting}[frame=single]
ex-t:Person [
    ottr:IRI ?person,
    xsd:integer ?age,
    ? List<ottr:IRI> ?fathers,
    ? List<ottr:IRI> ?mothers,
    ? List<ottr:IRI> ?ancestors,
    List<xsd:String> ?names
    ] :: {
    cross | ottr:Triple(?person, ex-r:hasFather, ++?fathers),
    cross | ottr:Triple(?person, ex-r:hasMother, ++?mothers),
    ottr:Triple(?person, ex-r:hasAge, ?age),
    cross | ottr:Triple(?person, ex-r:hasName, ++?names),
    ottr:Triple(?person, ex-r:ancestor, ?ancestors)
}.

ottr:Triple(_:b, ex-r:hasFather, ex-p:Roger) .
ex-t:Person(ex-p:Sebastian, 22 , (ex-p:Thommas, _:b), none, 
(ex-p:Thommas, ex-p:Roger), ("Sebastian"@no, "Bastian"@en)).
\end{lstlisting}

\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{stOTTRExample.png}
    \caption{A genralisation showing the syntax of stOTTR}
    \label{fig:stOTTERGenralisation}
\end{figure}

\subsubsection{Types in OTTR}
Basic types, LUB-types, and list types are the three list types that build up the OTTR type system. OTTR arranges the types in a subtype relationship, where the set of types are transitive and reflexive. The opposite or inverse of a subtype is a supertype. All the basic types, except for ottr:IRI and ottr:Bot, are common types taken from RDF, RDFS, OWL and XSD standards. ottr:IRI reference to the URI to a resource. ottr:Bot represents the type Bot, a subtype to all other types. In contrast to Bot, OTTR has the type Top, rdfs: Resource, a supertype for all other types.  Top is the default parameter type. If we want the parameter to have another type, we need to add the type before the parameter name explicitly.


\para
\emph{LUB} (LUB<>), denoted with ottr:Lub, stands for least upper bound. For every basic type P, there is also a LUB-type LUB<P> such that LUB<P> is a subtype of P. Furthermore, LUB<P> is compatible with all subtypes of P. While P, on the other hand, is compatible with all supertype of P. Furthermore, OTTR has two different types, \emph{List<>}, denoted with rdf:list, and \emph{NEList<>}, denoted with ottr:NEList. Where NEList stands for non-empty list. The OTTR type system assumes that there for each type P in the set of types exists a type List<P> and NEList<P> and that NEList<P> is a subtype of List<Q> for every type P that is a subtype of type Q.


\para
One of the reasons to have a type system in OTTR is to ensure that the use of types is consistent. So if we have a blank node, for example, which can be any type, and we use that blank node in an instance that excepts an xsd:integer. OTTR will then interpret the blank node as an xsd:integer in the rest of the template, which means sending this blank node as an argument to an instance that expects an xsd:string will result in an error message. The result of the type system is that the same resource always has the same type; in other words that the typing is concise. 

\subsubsection{Terms}
Terms in OTTR is the set of constants and variables where constants include lists, which is an order collection of terms. In addition to the constant nil, which is used to denote an empty list. The set of terms in OTTR are equal to the set of valid RDF terms, such as IRIs, blank nodes, literals. The only distinction between a variable and a constant term is in the template definition, where the variable occurs in a parameter declaration in the signature of the template.