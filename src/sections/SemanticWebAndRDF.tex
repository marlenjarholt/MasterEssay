%!TEX root = ../master.tex
\section{Semantic Web and RDF}
In general semantic web and semantic web technologies is an extension of World Wide Web,
but it dosen't refer to one concrete extension. The goal for the semantic web is to make is to 
make the data that are excesibal on the Internet readable for machine. The main way that the semantic web 
dose this is ot have \textit{linked date} which refers to that the identifiers are pointers to Web addresses 
where we can find more information about hte object.
The data that are conected needs som formal semanitc to work, e.g. RDF, RDFS, OWL etc. These components, shown in figure \nameref{fig:SW stack}
are used to among other things structure the linked data by providing a formal description
of terms, relationships and concept in the knowledge domain. In semanitc web and computer science in general 
we would call this an \textbf{ontologi}, which in short can be defined as the knowledge we have about a given 
domain which is machine-prosecassable and with a formally defined meaning.

\begin{figure}
    \centering
    \includegraphics[scale=0.2]{SWStack.png}
    \caption{The semantic web stack src: IN3060 foiler uke 2}
    \label{fig:SW stack}
\end{figure}


\subsection{RDF}
RDF stands for Resource Description Framework and it is a language for formally describing structure data, 
and is the general method in semantic web for describing information that is in a web resource. An RDF document often describes 
a directed graph which is build up by tripls which again are build up from subject predicate and object, but it can also represent 
a structure that we natrual wouldn't describe using graph. Due to that a resource both can be a subject/object and predicate
meaning that an element of the graph both can be an node and a edge. This is a relation 
from the subject to the object where the predicate tells ous about what the relationship is. In the grap the object 
and subject will be represented as node, with the predicate as an directed edge between the two from the subject to the predicate.
An collection of several will then result in a directed graph. An exampel of an triple can be that Sebastian hasFather Thommas, where 
Sebastian is the object, hasFather is the predicate and Thommas is the object. RDF have several serializations, we will use Turlte for exampels. 
\\ \\
To make this system work we somehow need to uniquely identify the different resources (subject, predicate and objects) of the graph, 
and this is called \textbf{URIs} (Uniform Resource Locators). Every URL is an URI ($URL\subseteq URI$), but it's important to note that 
not all URIs are URL ($URL\nsubseteq URI$). So if we now want to make the tripel made earlier we need to write it out with full URI, that could look 
some thing like this \textit{http://example.org/person/Sebeastian http://example.org/relation/hasFather http://example.org/person/Thommas}
But it can be time consuming to write the whole URI for Sebastian every time we whant to refer to the Sebastian resource, therefore we have something called prefix in 
turtle. We need to set the prefixes in the start of the file with this syntax \textit{@PREFIX ex-p: <http://example.org/person/> .} when we want 
to use the Sebastian resource we can just write $ex-p:Sebastian$. If we now add the the prefix for /relation as well \textit{@PREFIX ex-r: <http://example.org/relation/> .} 
the triple can be written as $ex-p:Sebastian\; ex-r:hasFather\; ex-p:Thommas\; .$.
\\ \\ 
In the ontologi of family, which we have now started to model, it could be nice to express that Sebastian has a father, without us knowing who the father is. 
This can be done with a \textbf{blank node}. In rdf a blank node tells ous that we don't know the URI for the resource, but that we either have some information 
on it or that some other resource is conected to it via a predicate, it is important to note that a blank not can be in the predicate position only in the subject and object
position. So to model that Sebastian has a father we can write either $ex-p:Sebastian\; ex-r:hasFather\; \_:b .$ or $ex-p:Sebastian\; ex-r:hasFather\; [\; ]$ , since the syntax 
for writing an empty node in turtle is either $\_:<some variable name>$ or $[\; ]$. Since an empty node also can be an subject we can express things about the resources. If we 
f.eks. want to model that Sebastian has a father which has a father how is http://example.org/person/Roger we can write $ex-p:Sebastian\; ex-r:hasFather\; [\; ex-r:hasFather\; ex-p:Roger]$
\\ \\ 
In RDF we also have something called literls for expressing stirngs, integer, etc. Literals can only be in the object position of the triple. 
So if we want to express that Sebastian has age 21 we can write $ex-p:Sebastian\; ex-r:hasAge\; " 22 " <opp greie> <opp greie> xsd:int.$ where xsd comes from the prefix
$@prefix\; xsd:\; <http://www.w3.org/2001/XMLSchema\#> .$. We can also model that Sebastian has the name Sebastian in norwiagen and Bastian in english by using 
language tags, this gives use the triples $ex-p:Sebastian\; ex-r:hasName\; Sebastian@no.$ and $ex-p:Sebastian\; ex-r:hasName\; Bastian@en.$. Here har our full 
graph:
\\ \\

\begin{lstlisting}[frame=single, language=turtle]
@prefix  ex-p:  <http://example.org/person/> . 
@prefix ex-r:  <http://example.org/relation/> . 
@prefix xsd: <http://www.w3.org/2001/XMLSchema/#>  . 
ex-p:Sebastian ex-r:hasFather ex-p:Thommas .
ex-p:Sebastian ex-r:hasFather [ ex-r:hasFather ex-p:Roger] . 
ex-p:Sebastian ex-r:hasAge  "22"^^xsd:int . 
ex-p:Sebastian ex-r:hasName  "Sebastian"@no . 
ex-p:Sebastian ex-r:hasName  "Bastian"@en .
\end{lstlisting}
In addition to the abbreviations we have already made turtle stile have some more abbreviations when writing the triples. For instanse if we have the same 
predicate and subject several times, with different objects, we can just write the predicate and subject one time and seperate the objects with a ,. Futhermore 
we can also abbreviate when we use the same subject severalt times by writne ; in the end of the line instead of . . This gives this turtle file:
\\ \\
\begin{lstlisting}[frame=single, language=turtle]
@prefix  ex-p:  <http://example.org/person/> . 
@prefix ex-r:  <http://example.org/relation/> . 
@prefix xsd: <http://www.w3.org/2001/XMLSchema/#>  . 
ex-p:Sebastian ex-r:hasFather ex-p:Thommas, [ ex-r:hasFather ex-p:Roger] ; 
                ex-r:hasAge  "22"^^xsd:int ; 
                ex-r:hasName  "Sebastian"@no, "Bastian"@en .
\end{lstlisting}

Figure \refname{fig:exampelGraph} is a visual graph of the graph we just made.
\begin{figure}
    \centering
    \includegraphics[scale=0.2]{exampleGraph.png}
    \caption{The visual graph over the graph made in section 2.1}
    \label{fig:exampelGraph}
\end{figure}

\subsubsection{Lists in RDF}
In RDF we have two main ways to represent list containers and collections. What is importent to
note is that you can by only using blank nodes as previously mention build up lists, or just
make every individual tripel said in other words the are just abbreviations. Lists in RDF are usually
used when we want to say that a subject have the same relation (or predicate) to several objects.
\\ \\ 
A container has three differents types, namely \textbf{rdf:Seq} (represents an order list), 
\textbf{rdf:Bag} (representing an unordered set) and \textbf{rdf:Alt} (representing a set of alternatives).
A container is build op of a blank node which needs to either have the rdf:type
rdf:Seq, rsd:Bag or rdf:Alt. One important thing to note is that the three different types
don't change (or effects) the structur, only how they will be display them in different applications.
To add nodes we will add a predicate $rdf\_1$ to $rdf\_n$ from the blank node to the member (the name used for 
elements of the container), where the first memeber has ralation $rdf\_1$ and n-th member has relation $rdf\_n$.
So if we whant to add an list to over rdf graph stating all Sebastian ancestors in a unorder set 
it will look like this (Note that we have used the abbreviation \textit{a} for rdf:type):
\begin{lstlisting}[frame=single, language=turtle]
@prefix  ex-p:  <http://example.org/person/> . 
@prefix ex-r:  <http://example.org/relation/> . 
@prefix xsd: <http://www.w3.org/2001/XMLSchema/#>  . 
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
ex-p:Sebastian ex-r:hasFather ex-p:Thommas, [ ex-r:hasFather ex-p:Roger] ; 
                ex-r:hasAge  "22"^^xsd:int ; 
                ex-r:hasName  "Sebastian"@no, "Bastian"@en ;
                ex-r:ancestor [a rdf:Bag; 
                                rdf:_1 ex-p:Thommas; 
                                rdf:_2 ex-p:Roger].
\end{lstlisting}
The second way to make a list is by using collections. The main differense between a container 
and a collection is that a collection is closed, menaing that we it can't be extended, 
while we can extend a container if we have the reference to the blank node (e.g. \_:list). The reason 
for this is that the linked list is build up like a linked list with \textbf{rdf:first} being a link to the member
and \textbf{rdf:rest} being a link to the rest of the list, when we the have reach the end of the 
list the rdf:rest will link us to \textbf{rdf:nil}. See \nameref{fig:containerAndCollection} to se the 
full structur of the example given above, this figure also shows the differences between the container version
and the collection version. Turlte have an abbreviation for writing collections and that is 
to use () and put all the members of the list insided it. In the general chase it will look like this 
$(member_1 \;member_2 .... member_n)$
To express that all Sebastian ancestors will then look like this:
\begin{lstlisting}[frame=single, language=turtle]
@prefix  ex-p:  <http://example.org/person/> . 
@prefix ex-r:  <http://example.org/relation/> . 
@prefix xsd: <http://www.w3.org/2001/XMLSchema/#>  . 
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
ex-p:Sebastian ex-r:hasFather ex-p:Thommas, [ ex-r:hasFather ex-p:Roger] ; 
                ex-r:hasAge  "22"^^xsd:int ; 
                ex-r:hasName  "Sebastian"@no, "Bastian"@en ;
                ex-r:ancestor (ex-p:Thommas ex-p:Roger).
\end{lstlisting}

\begin{figure}
    \centering
    \includegraphics[scale=0.2]{containerAndCollection.png}
    \caption{Shows the difference between a container and a collections in structur}
    \label{fig:containerAndCollection}
\end{figure}

\subsection{OTTR}
Reasonable Ontology Templates(OTTR) is language that represents ontology modelling patterns as paramaterised 
ontologies and is a way to make user-defined abstractions to recurring modelling patterns. 
OTTR is build up by \textbf{templates}, that consist of a \textit{head} that specifices the name of the templates
and the paramters, and a \textit{body} that contains the parameterised ontology pattern. We can also specify the types, which we will come back to, 
and the cardainality of the paramters. There are two types of cardainalities mandatory or optional, optional is denoted with 
a ? while mandatory is the the defualt and isn't denoted with any thing. In additon an paramter can be non-blank (meaning that it can't take inn 
a blank node) this is denoted with !. Parameters can also specify a defualt value, that is used 
whenever the corresponding argument in a instead of that template is none (a value in the OTTR framework used to represent a missing or no value). 
\nameref{fig:stOTTERGenralisation} shows a generalisation of OTTR written in the seralisation stOTTR.
\\ \\
The template body can also use expanssion mods on instances that 
at least on argument that is a list. Every argument in the instance will temporarily be treated as a list in the expanssion mods, but lists that 
are marked with the list expanssion (++ infront of the argument) are kept as they are, while the other arguments are treated as 
a list with one element. There are three different list expanssion mods cross, zipMin and zipMax. They behave the same when only one list argument
is marked with a list expanssion, but when serveral list are marked they behave different. Cross gives one instance per element in the cross-product. zipMin 
makes one instance per element in the smallest list (making n instances, where n is the length of the smallest list), and relating the element on the same index 
i in the lists. zipMax is almost the same as zipMin, but instead of choosing the smallest list zipMax makes one instaces for every element in the largest list,
to be able to do this OTTR extends the other lists with none until they are as long as the longest list.   
\\ \\
To use the templates is what is called an OTTR \textbf{instance}, often called tamplate instance contains the name of the tamplate that are to be used, 
and a list of arguments that matches that parametes that mathces the parametes that are specified in the tamplate. 
The pattern in the body is made out of instances of other templates until we reach what is called a \textbf{base template}. 
In RDF the base template is the TRIPLE template which represents a single RDF tripel, and takes in three arguments a subject,
a predicate and a object (in that particular order). Recursion is used to \textit{expand} the instances in to RDF graphs, with recursivley
replacing all the instaces in the body with the pattern they represent. The recursion stops when it reaches a base template.
OTTR has four seralisations for representing the templates and the instances, stOTTER, wOTTR, tabOTTR and bOTTR. stOTTER is a custum serializations
for OTTR, made to be compacte easy to ready for humans, and is partily based on parts from RDF turtle grammar.
wOTTR is an seralisation that is written in rdf and specified by an OWL ontology and uses SHACL to define the grammar. Futhermoe tabOTTR is
a way to create instances from spreadsheets and bOTTR can make mappings over serveral queryable sources. The following OTTR template 
made makes a person, the instance of ex-t:Person will expand to the rdf graph made earlier.

\begin{lstlisting}[frame=single]
@prefix  ex-p:  <http://example.org/person/> . 
@prefix ex-r:  <http://example.org/relation/> .
@prefix ex-t:  <http://example.org/template/> . 
@prefix xsd:  <http://www.w3.org/2001/XMLSchema#> . 
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix ottr: <http://ns.ottr.xyz/0.4/> .


ex-t:Person [
    ottr:IRI ?person,
    xsd:integer ?age,
    ? List<ottr:IRI> ?fathers,
    ? List<ottr:IRI> ?mothers,
    ? List<ottr:IRI> ?ancestors,
    List<xsd:String> ?names
    ] :: {
    cross | ottr:Triple(?person, ex-r:hasFather, ++?fathers),
    cross | ottr:Triple(?person, ex-r:hasMother, ++?mothers),
    ottr:Triple(?person, ex-r:hasAge, ?age),
    cross | ottr:Triple(?person, ex-r:hasName, ++?names),
    ottr:Triple(?person, ex-r:ancestor, ?ancestors)
}.

ottr:Triple(_:b, ex-r:hasFather, ex-p:Roger) .
ex-t:Person(ex-p:Sebastian, 22 , (ex-p:Thommas, _:b), none, 
(ex-p:Thommas, ex-p:Roger), ("Sebastian"@no, "Bastian"@en)).
\end{lstlisting}

\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{stOTTRExample.png}
    \caption{A genralisation showing the syntax of stOTTR}
    \label{fig:stOTTERGenralisation}
\end{figure}

The criticism one can come up with to this idea is that it allready exisits ways to add inffered data to an RDF-graph, both 
with functions and adding new trippels. 

\subsubsection{Types in OTTR}
The type system in OTTR are build from three types of types, namely basic type, LUB-type and list type. The types are arrange in 
a subtype relationship, where the set of types are transative and reflexive. The opposite or invers of a subtype is a supertype.
All the basic types, except for ottr:IRI and ottr:Bot, are common types taken from RDF, RDFS, OWL and XSD standards. ottr:IRI reference 
to the URI to a resource. ottr:Bot represents the type Bot. Bot is a type that is the subtype to all other types. In addition no term can 
be of type Top, except for the term none. 
While the type Top (represented with rdfs:Resource) on the other side is every type supertype.
\\ \\
LUB, \textbf{LUB<>} (denoted with ottr:Lub), stands for least upper bound, and for every basic type P there is also a LUB-type LUB<P> such that LUB<P> is 
a subtype of P. Futhermore LUB<P> is compatible with all subtypes of P while P on the other hand is compatible with all supertype of P. 
Futhermore we have to different types \textbf{List<>} (deonted with rdf:list ) and \textbf{NEList<>} (denoted with ottr:NEList), where 
NEList stands for non empty list. In addition the 
type system assume that there for each type P in the set of types exists a type List<P> and NEList<P>, and that 
NEList<P> is a subtype of List<Q> for every type P that is a subtype of type Q.
\\ \\
One of the reasons to have types in OTTR is to make sure that the use of types is consistens. So
if we have a blank node for exampel, which can be any thing (an ottr:IRI, xsd:string, xsd:integer, etc), and we use that blank node 
in an instance that excepts an xsd:integer, this blank node will now be interpreted as an xsd:integer in the rest of the template. 
Meaning that sending this node as an argument to a instance that expects a xsd:string whould give an error message. The result of this 
is that the same resource allways have the same type, in other words that the typing is concise. 

\subsubsection{Terms}
Terms in OTTR is the set of constants and variables. Where constants includes list (which is an order collection of terms), and
the constant nil is used to denote an empty list. The set of terms in OTTR are equal to the set of valid RDF terms (IRIs, blank nodes, literals).
The only destinction between a variable and a constant term is in the template definition, where the 
variable occures in a parameter declaration in signatur of the template.