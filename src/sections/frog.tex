%!TEX root = ../master.tex
\section{Frog}

\subsection{Motivation}
The use of OTTR templates proposes some benefits, such as better \emph{abstractions} and \emph{uniform modelling}, among other things. OTTR uses template patterns as an abstraction for low-level RDF triples and OWL axioms. Nonetheless, one may say that OTTR has the possibility to abstract even further. For instance, OTTR has no support for making URIs. Before using a template, one then has to make the URIs if they are none existing. Imagine that we have made a template that formally describes a person, with their social security number, name, age. Using the social security number in the URI is natural since this is uniquely identifying. Furthermore, we want to use the template on different sources, such as a tabular document and a CVS document. The template user has to construct the URIs differently in the different sources before using the template. OTTR being able to create the URIs in the template body would then further improve OTTR's benefit of abstraction. Additionally, creating URIs in the template body will benefit uniform modelling because it eases the \emph{maintenances}. Since changes in the URI structure only have to be done in the template and not in every source.

\para
Conceptualize that we want to store information about the weather. We want to use several sources for the data, perhaps several different CSV files. Most of the files use Celcius as their temperature scale, but a few of the files stores the temperatures in Fahrenheit. We, however, want to store all the temperature data in one standard temperature scale, namely Celcius. We have to either manually or by using a script convert Fahrenheit to Celcius before making instances from the data. However, this may be solved in the OTTR templates if it had been possible to do a simple operation on the Fahrenheit degrees. Doing the transformation manually from Fahrenheit to Celcius is time-consuming for big data sets. The second solution is still a solution, but this requires the template user to either know how to make a script for converting the degrees or use an exciting one. Using or making a script may interfere with one of the benefits of using OTTR, namely \emph{separation of design and content}. Separation of design and content in terms of OTTR means that it separates between the design of the knowledge base, the templates, and the knowledge base's content, the instance. Then the ontology experts can manage templates, and domain experts use familiar tools to create instances. The domain expert is not necessarily an expert on how to use scrips or make them. Ideally, the converting from Fahrenheit to Celcius should then be part of the design of the knowledge base. 

\para
To solve these issues, we propose a functional language that can make functions to manipulate the terms in OTTR, Frog. If needed, instances in a template body can use a Frog function to manipulate one or several arguments, for instance,  making a URI from a social security number or converting  Fahrenheit to Celcius. As previously mentioned, OTTR has a type system. Therefore, naturally, Frog will use the same type system, resulting in Frog being a typed language with parameter types and a return type.  The benefit of Frog being a types system is that we can perform we still can perform type checking in the templates. It is crucial to note that Frog only can manipulate terms and not change the graph; therefore, Frog will be a purely functional language. The idea is that Frog will have several language similarities to Scheme and other LISP languages and be written in RDF.

\para
Having a language like Frog also makes it possible to add infeed data. For instance, if we have the template ex-t:Person from earlier and we want to add a tripel to the expanded template containing the information about whether the person is of type adult (ex-p:Adult) or of type child (ex-p:Child). This is information that can be inferred from the age variable. As a result, we can make a new rdf-o:type with the person as the object and the result of the function ex-r:ageToLifeStage as the object. Where ex-r:ageToLifeStage is a Frog function that takes in an xsd:integer as an argument and returns a ottr:IRI. The ottr template below shows the potential use of the frog function in the ex-t:Person.

\begin{lstlisting}[frame=single]
    
ex-t:Person [
    ottr:IRI ?person,
    xsd:integer ?age,
    ? List<ottr:IRI> ?fathers,
    ? List<ottr:IRI> ?mothers,
    ? List<ottr:IRI> ?ancestors,
    List<xsd:String> ?names
    ] :: {
    cross | ottr:Triple(?person, ex-r:hasFather, ++?fathers),
    cross | ottr:Triple(?person, ex-r:hasMother, ++?mothers),
    ottr:Triple(?person, ex-r:hasAge, ?age),
    cross | ottr:Triple(?person, ex-r:hasName, ++?names),
    ottr:Triple(?person, ex-r:ancestor, ?ancestors),
    rdf-o:Type(?person, (ex-f:ageToLifeStage ?age))
}.
\end{lstlisting}

The expansion the two following two instances

\begin{lstlisting}[frame=single]
ottr:Triple(_:b, ex-r:hasFather, ex-p:Roger) .
ex-t:Person(ex-p:Sebastian, 22 , (ex-p:Thommas, _:b), none, 
(ex-p:Thommas, ex-p:Roger), ("Sebastian"@no, "Bastian"@en)).

ex-t:person(ex-p:Nina, 6, none, none ,none, ("Nina"@no))
\end{lstlisting}

will then be
\begin{lstlisting}[frame=single, language=turtle]
ex-p:Sebastian ex-r:hasFather ex-p:Thommas, [ ex-r:hasFather ex-p:Roger] ; 
                ex-r:hasAge  "22"^^xsd:int ; 
                ex-r:hasName  "Sebastian"@no, "Bastian"@en ;
                ex-r:ancestor (ex-p:Thommas ex-p:Roger);
                a ex-p:Adult.

ex-p:Nina ex-r:hasAge  "6"^^xsd:int ; 
          ex-r:hasName  "Nina"@no ;
          a ex-p:Child.
\end{lstlisting}

\subsection{Plans for Frog}
Frog is a high-order function programming language, only allowing pure function. Furthermore, Frog utilises RDF for expressing its syntax. We amplify Frogs syntax in section \label{frog syntax}. Frogs goal is to make it feasible to manipulate the terms in the OTTR template body using Frog functions. In addition, Frog has two types of functions, one type that is named and anonymous function, making it possible to write anonymous functions straight into the OTTR template body. However, we specify the named functions in an other file, and OTTR can then use the function in the OTTR template body. Since Frog is a part of the OTTR framework, it will use the same type system and term system as Frog. Frog requires that we state the return type of the function and the types of the parameter explicitly, meaning that Frog is a typed programming language. We further elaborate on the use of types in Frog in \autoref{types in frog}.

\subsubsection{Proposed syntax}
\label{frog syntax}
Frog's syntax has some properties that needs to be fulfilled: 
\begin{enumerate}
    \item The language shall be written in RDF 
    \item A named function should know its type. Where the type is a combination of the parameter types 
    and the return type of the function.
    \item A named function is not a function until the rdf:type is set as an Function
    \item The body of the function shall be build up by list, like the LISP languages
\end{enumerate}

\subsubsection{Proposed semantics}
\begin{enumerate}
    \item riktig bruke av termer 
    \item at det funksjonen sier at typen til det en returner faktiks er riktig
\end{enumerate}

\subsubsection{Evaluation}
Frog utilises lazy evaluation to evaluate its expression. We have chosen to use lazy evaluation to ensure that Frog does not perform unnecessary evaluations. Since Frog is a pure programing language using lazy evaluation is optimal because we know that Frog function always returns the same value for a set of arguments. We chose not to utilise eager evaluation in Frog because Frog does not support I/O and error features. Additionally, using a lazy evaluation approach makes it possible, as previously mentioned, to add features like streams.

\para
Furthermore, we have also chosen to use a lazy evaluation approach in the OTTR templates to determine when OTTR should evaluate the function—resulting in OTTR only evaluating a function call when the function call reaches a base template. Why lazy evaluation is a better approach than eager evaluation, in this case, is that OTTR does not force a user to use all variables in the template, even though OTTR throws a warning. Therefore, using lazy evaluation assures us that OTTR only evaluates function calls needed to expand the template.  

\para
Using lazy evaluation as an evaluation strategy also adds, as previously mentioned, memorisation. As previously mentioned, OTTR only evaluates a function call when it reaches a base template—utilising memorisation is then an advantage in OTTR because we do not know how many base templates a function reach. To summarise, lazy evaluation and memorisation assure that OTTR only evaluates a function call once and only if the result of the function is needed.

\subsubsection{Type sytem in Frog}
\label{types in frog}
As already stated, Frog uses the same type system as OTTR. Using the same type system is beneficial because OTTR and Frog assure us that the term returned by the function matches the type the OTTR template parameter requires. Frog and OTTR using the same type system is especially important for the OTTR specific types, such as BOT, LUB-types and list-types, since the OTTR specific types may not have an optimal counterpart in another type system.

\para
Endringer som trengs å gjøres på OTTR sitt type system. Først og fremst en functions type, trenger ikke en function call type da et function call type vil evalure til å være return typen. Muligens skille på anonyme funksjoner og funksjoner med navn.

\para
NOTE: Muligens dette og den neste avsnittet bør få en egen section
Even though OTTR and Frog use lazy evaluation, OTTR needs to check that the term returned by the function has the correct type. Since OTTR, as mentioned, throws an error if an argument has the incorrect type. Checking that the type matches is necessary to do at this stage since the base template may use a more general type. A more general type in this sense means that the type is a supertype of the original type. An excellent example is ottr:Triple, where the third parameter has the type top; this means that the third parameter type is compatible with every term since the top type is the supertype of all types. An additional advantage of doing the type checking at this stage is that OTTR detects errors earlier. An alternative approach is to store the function call and the expected type of the argument in an object. As a result of storing the expected type and the function call in an object, OTTR can perform the type checking when the function call reaches a base template. However, this approach is not optimal since OTTR throws a typing error regardless of the function call reaching a base template. 

\para 
As mentioned, Frog makes it feasible to anonym functions straight into the OTTR template. Anonym functions dose does not state their return type. Since OTTR needs to know the return type of a function call, Frog needs to use some typing rules to determine the return type based on the function body and the parameter type. In contrast to named functions, the anonymous functions do not explicitly state their parameters. Frog solves this by setting the type of the parameters to the same type as the given argument term has. 

\subsubsection{Validation of functions}
At some point, Frog needs to validate the syntax and semantic of a function. For the time being, we have only talked about validating that a function's return type matches the OTTR templates corresponding parameter type.  OTTR does some validations before expanding an instance. Such as checking that the syntax is correct. Naturally, Frog also does some validation before OTTR starts to expand the instances. As OTTR, Frog also checks the syntax in advance. In addition, to validate some parts of the semantic. For instance, Frog validates that every function used in the function receives terms with the correct type. Resulting in that if a function uses a function, add, which takes in two terms of type xsd:integer. Then Frog validates that the two arguments given to add are terms of type xsd:integer. Furthermore, Frog also validates the function, and the function utilised in the function returns a term of the type that they state.

\para
avsnitt om hvordan Frog skal validere anonyme funksjoner som er brukt inne i 


\subsubsection{Termination}
There are several different ways to guarantee termination. As mention in the section about type theory, 
it is possible to make a type system for a programming language that guarantees termination. However, this often results in less expressive languages. 
Another approach is to make a set of base functions that can be used to build a new function, as described in the section about combinatory logic. 
Where the base functions are guaranteed to terminate. The reason why guaranteed termination would be a nice feature in Frog is that a valid OTTR template guarantees termination. 
Meaning that if Frog does not guarantee termination, OTTR templates that uses Frog functions can not guarantee it either
   

\subsubsection{Div}
PLAN:
\begin{itemize}
    \item Skrive at man vil tilby de "klassikse" funksjonen map, filter og reduce
    \item Skrive om hvordan funksjonene skal lages, skal vi bruke en code genrator (ulempe: krever vedlikehold), en for hver type (ulempe: tid krevende. Finnes uendlige mange typer), generisk (kan fungere, da kan f.eks. add -funksjonen bli lagd for den mest generiske typen for tall)
\end{itemize}


\subsection{Alternative approaches}
In this section, we will propose alternative approaches to Frog.  We group the approaches into two groups.  Firstly, we will consider how we can utilise different semantic technologies, namely SPARQL, OWL, and SWRL,  on the expanded OTTR template to yield the same result compared to Frog in some cases. Additionally, we will propose a way to solve some of the example issues presented in the motivation section using these semantic technologies.  Secondly, we will discuss two different languages for doing computation on RDF, Ripple and RDF, and how these may be an alternative to Frog. 

\subsubsection{SPARQL}
SPARQL is a query language over RDF with many similarities to SQL for relational databases, such as SELECT, WHERE, and GROUP BY. These clauses are also build up similarly in SPARQL and SQL.  Like SQL, SPARQL also offers clauses to delete data from the graph and insert data. Additionally, SPARQL also offers BIND, which allows us to assign values to a variable. Consequently, BIND makes it possible to make simple functions and bind the result of the function to a variable. Using a combination of an insert clause and BIND will then make it possible to add data to the graph from calculations.

\para
In the section about the motivation for making Frog, we described an example where we only wanted to store degrees in Celcius. However, some of the sources used Fahrenheit, resulting in a needed conversion. A possible solution to this problem, and similar ones, is to use SPARQL. Firstly we can make the triples using OTTR. Secondly, make a BIND that converts the existing Fahrenheit degrees to Celcius and use an insert clause to add the Celcius degree to the graph. Lastly, use a delete clause to delete all the triples which contain the degrees in Fahrenheit.

\para
Using SPARQL instead of a FROG function can yield the same result, meaning that SPARQL could be an alternative approach to FROG. However, in addition to SPARQL demanding more steps to get the same result, this technic does not preserve the benefit of abstraction as good as FROG. Having several steps may also result in more maintenance. In addition, one of FROG goals is that we only can manipulate the terms and not the whole graph. Using SPARQL, on the other hand, will manipulate the graph and not only the term. Consequently, using SPARQL as an alternative would not preserve the benefits of using FROG.   


\subsubsection{OWL}
Web Ontology Language (OWL) is an ontology language for the Semantic web, based on description logic. OWL provides us with classes, data properties, object properties, and instances. In addition, OWL defines ways to model classes, properties, and instances using logic. Among other things, OWL makes it feasible to model role restrictions. Role restrictions let us model classes as a set of objects that either only (universal restriction) have a role to a given set or has some (existential restriction) role to a given set.  With role descriptions and OWL, one can, for instance, express that a student takes some courses or that all plants only drink water. OWL also provides cardinality on roles, making it possible to express that all cats have four paws, for instance.

\para
Combined with reasoning, OWL can add infeed data to a graph. If we take the life stage example from the motivation section, one can make an ontology with OWL that states that all ex-p:Adult has some age greater than 17, and all ex-p:Child has some age less than 18—giving the persons the correct type.

\para 
To conclude, OWL can add inferred data to the graph. However, this is not the primary goal of Frog, which is to perform manipulation on terms, but more an additional feature. Moreover, using OWL has restrictions. We could not, for instance, use OWL to model that something with age over 17 has the ex-r:lifeStage ex-p:Adult. Meaning that OWL expects the data structured. Frog, on the other side, only works on the terms. Additionally, making function, or do computations on terms, is not possible with OWL. TODO: Legge til at det fjerner abstraction, og at ottr er "lagd" for å kunne lage axioms. 

\subsubsection{SWRL}
SWRL is a proposed language for the semantic web. SWRL can express rules and logic, combining OWL and a subset of Rule Markup language. In addition, SWRL also offers several functions that can we can use on different types, such as xsd:integer. However, SWRL does not allow us to make new functions only use predefined ones. Furthermore, an SWRL statement has two parts, a body and a head. The body is a set of conditions, while the head is the consequence of the conditions.

\para
Moreover, we can use SWRL to solve the life stage example and the Fahrenheit to Celcius example and similar problems. First, in the life stage example, we need to make two rules, one for the adult and one for the child. The first conditions are equal for both rules, namely that one has an age. In addition, the rule concluding in the rdf:type being ex-p:Child needs a condition stating that the age is less than 18, using the swrl:lessThan function. Concluding that the rdf:type is ex-p:Adult, on the other side, needs a second condition declaring that the age is greater than 17, using swrl:greaterThan. Likewise, SWRL can convert the Fahrenheit degree to Celcius, where we, in the conclusion, could combine several math functions offered by SWRL to convert the degree.

\para
\begin{itemize}
    \item Skrive om hvordan SWRL lar oss gjøre mye av det vi er ute etter
    \item Vi kan ikke gjøre utregninger på noe som trenges under OTTR templatet
    \item Alle kalkulasjoner må gjøres etter at instansen er expanded 
    \item maintenance og abstraction
    \item ottr har ikke noe rule language, selv om frog ikke er et rule language kan man bruke det til å lage regler. 
\end{itemize}

\subsubsection{Ripper}
Ripple is a functional, stack-based query language that allows us to both make queries and functions that we can use on RDF. Ripples interface has two different statements: making queries and making what they call commands or directives. Combining the command, define, and querying can make functions.   

\para
Ripple has numerous similarities to Frog, such as being functional, using lazy evaluation and using a nested list structure. Compared to the semantic technologies, making a function call using a Ripple function inside an OTTR template may be possible. As a result, making necessary calculations before expanding the instances, such as making a URI, is possible. However, using Ripple as an alternative may yield one problem: different typing and term systems. Meaning that, for instance, checking that a return type matches the expected type of the argument may be difficult. These problems may be complicated to solve for the OTTR specific types like the LUB and list types.    

\subsubsection{Adenine}
Another alternative approach that is similar to Ripper is Adenine. Adenine is a language written for project Haystack to more effectively make and manipulate RDF-data, meaning that it can change the graph directly with, e.g. adding new tripels. Adenine is an imperative language that has a syntax that can resemble a combination of Python and lisp. 

\para
Like Ripper, one of the problems for using Adenine as an alternative approach is that OTTR and Adenine do not utilise the same type or term system. Additionally, Adenine does not change or manipulate terms but whole graphs. Consequently, Adenine needs, similar to the semantic technologies, to work on the expanded OTTR instances. Working on the expanded instances has mainly two consequences. Firstly, making functions that return a value that OTTR needs to expand the instances, like making URIs, is impossible. Secondly, this may not improve   TODO: hvordan dette kan "ødlegge" for abstractions

\subsubsection{Summarisation}
\begin{itemize}
    \item Snakke om de to hoved approchene
    \item Forklare hvorfor Adenine og Ripper ikke fungerer, mtp at det vi bruker Frog i OTTR ikke er rdf men termer
    \item 
\end{itemize}

\subsubsection{OLD STUFF}
The reason it still will be nice to have a language like frog that can be used in the template compared to the 
methodes mention over is that the functions becomes a part of the domain. In additon the methods mention over implies
that we have to add the inffered information before using template. Frog on the other side will offer the abilities to 
do this directly in the template. 
\\ \\
In additon an alternative approache to Frog which is not already meantion and which is not a part of semanitc web 
is using a scripting language to write the functions.
The benefits of making a whole new language like Frog for making functions instead of using a scripting language is 
that is that the types used in frog matches the types in OTTR (in additon to frog doing type checking) meaning that 
the we don't need to transelate types from one type system to another (from the scripting language to OTTR). This means 
that frog probably will be less error-prone than using a scripting language.

\subsection{Summary and Problem Statment}