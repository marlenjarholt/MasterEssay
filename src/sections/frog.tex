%!TEX root = ../master.tex
\section{Frog}

\subsection{Motivation}
There are no ways change or mainpulate the terms (lists, liters etc) in OTTR. Imagen that you 
make a template for storing information about the weather, you have made sevral hundres instances. Say that one of the 
triples the is made from expanding the template to rdf states somethings temprature in farenheit but you need the temprature in celcius.
For now you how to change the term, meaning that you have to change the degrees manually (or using a scrip) for every OTTR instances.
The goal of Frog is to solve this problem with being a programming language written for OTTR where we are abel to change 
the terms using function. In the farenheit celcius exampel the solution with frog is then to make a function that can be used 
in the template body to convert the farenheit variable given in the head to celcius. 
\\ \\
Having a language like Frog that can make simple functions to mainpulate terms can do more than just convert terms, it can 
also make it possible to add new inffered information. E.g. if we have the template ex-t:Person from earlier
and we want to add a tripel to the expanded template containing the information about whether the person is of type adult (ex-p:Adult) or of type child (ex-p:Child). This 
is information that can be inffered from the age variable, we can make a new rdf-otype with the person as the object, rdf:type as the 
predicate and the result of the function ex-r:ageToLifeStage as the object. Where ex-r:ageToLifeStage is a frog function that takes in an xsd:integer
as argument, and returns a ottr:IRI. The ottr template bellow shows the potential use of the frog function in 
the ex-t:Person.

\begin{lstlisting}[frame=single]
@prefix  ex-p:  <http://example.org/person/> . 
@prefix ex-r:  <http://example.org/relation/> .
@prefix ex-t:  <http://example.org/template/> . 
@prefix ex-f:  <http://example.org/function/> .
@prefix xsd:  <http://www.w3.org/2001/XMLSchema#> . 
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix ottr: <http://ns.ottr.xyz/0.4/> .
@prefix o-rdf: <http://tpl.ottr.xyz/rdf/0.1/> .

ex-t:Person [
    ottr:IRI ?person,
    xsd:integer ?age,
    ? List<ottr:IRI> ?fathers,
    ? List<ottr:IRI> ?mothers,
    ? List<ottr:IRI> ?ancestors,
    List<xsd:String> ?names
    ] :: {
    cross | ottr:Triple(?person, ex-r:hasFather, ++?fathers),
    cross | ottr:Triple(?person, ex-r:hasMother, ++?mothers),
    ottr:Triple(?person, ex-r:hasAge, ?age),
    cross | ottr:Triple(?person, ex-r:hasName, ++?names),
    ottr:Triple(?person, ex-r:ancestor, ?ancestors),
    rdf-o:Type(?person, (ex-f:ageToLifeStage ?age))
}.
\end{lstlisting}

The expansion the two following two instances

\begin{lstlisting}[frame=single]
ottr:Triple(_:b, ex-r:hasFather, ex-p:Roger) .
ex-t:Person(ex-p:Sebastian, 22 , (ex-p:Thommas, _:b), none, 
(ex-p:Thommas, ex-p:Roger), ("Sebastian"@no, "Bastian"@en)).

ex-t:person(ex-p:Nina, 6, none, none ,none, ("Nina"@no))
\end{lstlisting}

will then be
\begin{lstlisting}[frame=single, language=turtle]
@prefix  ex-p:  <http://example.org/person/> . 
@prefix ex-r:  <http://example.org/relation/> . 
@prefix xsd: <http://www.w3.org/2001/XMLSchema/#>  . 
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
ex-p:Sebastian ex-r:hasFather ex-p:Thommas, [ ex-r:hasFather ex-p:Roger] ; 
                ex-r:hasAge  "22"^^xsd:int ; 
                ex-r:hasName  "Sebastian"@no, "Bastian"@en ;
                ex-r:ancestor (ex-p:Thommas ex-p:Roger);
                a ex-p:Adult.

ex-p:Nina ex-r:hasAge  "6"^^xsd:int ; 
          ex-r:hasName  "Nina"@no ;
          a ex-p:Child.
\end{lstlisting}

\subsection{Plans for Frog}
The plan is that frog is a language that is written in RDF. In addition to being a high-order functional language, 
with only pure functions. 
Frog will also have a type system, which we will come back to, and it should be clear form the definition of 
the function what the type of the different parameters are and the type of the return value. 
A frog function can only take in arguments and an return values that are a type from the OTTR type system, 
meaning that frog will have the same type system as OTTR and the same term system as OTTR.
The advantage of this is that frog can do type checking, since a function has a return value we can check that 
the type of the return value is of the same type that the argument in the instance needs to be.
Since frog is supposed to be a high-order language and will have the same type system as OTTR  
we need to add a new type to the OTTR type system, namely a function type that we need to give to every frog function. 
There is one exception to frog being high-order and that is that a function that is used directly in a 
template (like ex-f:ageToLifeStage in ex-t:Person) aren't allowed to return a function type. Due to addiong a new 
fnction type in the OTTR type system we also need to add terms that maches the new type. 

\subsubsection{Proposed syntax}
Frog's syntax has some properties that needs to be fulfilled: 
\begin{enumerate}
    \item The language shall be written in RDF 
    \item A named function should know its type. Where the type is a combination of the parameter types 
    and the return type of the function.
    \item A named function is not a function until the rdf:type is set as an Function
    \item The body of the function shall be build up by list, like the LISP languages
\end{enumerate}



\subsubsection{Evaluation}
The plan for evaluation is to use a lazy evaluation approache. Lazy evalution will then be used in the functions it self, 
but also when we are supposed to evaluate it in the ottr template. The result of this is then that the functions aren't evaluated 
for before it reaches an base template (like ottr:Triple). Why this in this case is a better solution than an eager evalution 
approache is that OTTR doesn't froce the user to use all variables in the template (even though a warring is thrown), therefor using 
lazy evaluate would mean that we are not evaluating the function if it's never used. Using lazy evaluation as an evaluation 
strategie will than in addition add memorization, the reason why this is a good idea in this case is that when we have no why 
off knowing when calling an instance with a function as one of the arguments (if it isn't a base template) how many times this 
value would end up in a base template. Lazy evaluation would then make sure that the function really only is evaluated once for this 
function call and only if the value of the function ever is needed. 

\subsubsection{Type checking in ottr}
Even though Frog will use lazy evaluation to evaluate a function call it will check that the type returned by the function is compatible with 
the the parameter type for that given arguement. Meaning that calling a function that returns an xsd:strin on an instance that 
expects an xsd:integer will throw an error. The reason why this has to be done at this stage is that the base template can be typed 
more generaly than what the template that makes the instances is, with general meaning that the type in the template of the instance
is a subtype of the type in the base template. An good example of this is the base template ottr:Triple which takes in 3 arguments that 
are ottr:Resources meaning that the arguments can be of any of the other types in the ottr type system since every type is a subtype of 
ottr:Resource, meaing that checking that the type returned by the function is compatible at this stage could result in a wrong answer. 
An alternernativ approch, where the type checking also is done when the function reaches a base template, whould be to make a wrapper 
class which contains the function call and the expected type of the argument, and the evaluate that the type matches first when we need 
to use the function. The reason why this wouldn't be the best approache is that we are not guaranteed that the function reaches a 
base template at some ponit, but ottr throws an type error regardless.
\\ \\
We also want it to be possible to write lambda-functions or anonym functions straight in to the ottr template. Since we want to check that 
the type returned by the function is compatible with the type that the template expects. This means that we have to be able to evaluate from 
the lambda function what type it will resolve to be. One methode to do this can be to use the same typing rules that are used in 
simply typed lambda calculus. The difference between simply typed lambda calculus and Frog lambda functions (for now) is that simply typed 
lambda calculus have the paramtertypes while Frog won't (because for now frog only set parameter types )  TODO

\subsubsection{Functions on lists}
TODO

\subsubsection{Termination}
There are several different ways to guarantee termination. As mention in the section about type theory, 
it is possible to make a type system for a programming language that guarantees termination. However, this often results in less expressive languages. 
Another approach is to make a set of base functions that can be used to build a new function, as described in the section about combinatory logic. 
Where the base functions are guaranteed to terminate. The reason why guaranteed termination would be a nice feature in Frog is that a valid OTTR template guarantees termination. 
Meaning that if Frog does not guarantee termination, OTTR templates that uses Frog functions can not guarantee it either

\subsection{Alternative approaches}
There are several methods that allready exist to add inffered information to rdf graphs, using function or other methods. 
One way you can do this is with SPARQL, which is a query language over RDF with many similarities to SQL for relational 
databases e.g. that they have SELECT, WHERE, GROUP BY, etc, that are build up in a similar fashion. In SPARQL you can use 
a INSERT DATA clause which insert the data in the field in to the graph, combind with a WHERE-clause, and possible a BIND. 
In sparql BIND allows values to be assing to a veriable, meaning that we can make simple functions and bind the result of 
the function to a variable, which again can be used in INSERT DATA clause to add it to the rdf graph. The example that was
described earlier, with converting farenheit to celcius can then be done by using this technique (but here we'll end up with a 
triple with both celcius and farenheit is we don't delete the farenheit afterwards). 
\\ \\
An other alternative to Frog and it's functionalty is OWL. OWL is a Semantic Web language that are made for representing complex 
knowledge, and it's based on logic. In owl we can define the descriptions of classes. Then can use already existing 
predicates and classes to define new ones from inffered information. E.g in the example mention eariler where we defined in the template
with a frog function, wheter the type of the object was child or an adult. This could have been done with modelling in OWL. If we say that  
ex-p:Adult as everthing that has age bigger then 17 and ex-p:Child as everything that has age equal or bigger then 17.
\\ \\
The last method used in the semanitc web we will mention is SWRL, which is a proposed language for semanitc web. SWRL can be used 
to express rules and logic, and is a compination of OWL and a subset of Rule Markup language. SWRL also offers several function 
which can be used on different types (from, rdf, xsd, and owl), but we can not make our own functions, only use the ones that 
SWRL has defined. SWRL is build up with a body that are a set of conditions and a head which is the consequences of the
conditions. Yhe exampel from eariler where we either added the type ex-p:Child or ex-p:Adult can be solved in SWRL with 
making two rules, one for ex-p:Child and one for ex-p:Adult. In the rulte for ex-p:Child we need two condtions on which 
state that the person has an age and one which checks that the age is less than 18 (for this we can use the SWRL function
swrl:lessThan), the conclution of this rule is that the type of the person is ex-p:Child. The ex-p:Adult rule will look 
similar, the conditions will be that the person has an age and that the age is greater then 17 (using the SWRL function 
swrl:greaterThan) and that has the condition that the person has type ex-p:Adult. We can also express the converting from farenheit
to celcius with SWRL using the condition that it has a farenheit temparture and a combination of math functions offerd by SWRL to 
make the conversion as an condition.
\\ \\
(Source: http://sunsite.informatik.rwth-aachen.de/Publications/CEUR-WS/Vol-248/paper10.pdf mulig utdatert ?? tror den er fra 2007 
men klarer ikke å finne datoen den ble publisert. ? er skrevet etter de tingene jeg må sjekke om fortsatt faktisk stemmer)
Another possible approache would be to use Ripper, which is a language that can make functional (debatable) programs from linked data
and querie over linked data, where linked data referes to RDF. 
Ripple is written in RDF, just like we Frog, but Ripple has its own seralization that is based on 
Turtle. Rippel is also a stack based language and operates on a stream that can contain any number of stacks.
The reason why using Ripple whould not be an optimal solution is that it dosne't use the same type system and has 
the same types as OTTR.   
\\ \\
Another alternativ approache that is similar to Ripper is Adenine. Adenine is a language that was written for project 
haystack to more effectively make and mainpulate RDF-data, meaning that it can change the graph directly with e.g. adding 
new trippels. 
Adenine is a imperative language that has a syntax that can resemble a combination of Python and lisp.
There are several reasons why Adenine isn't optimal to use istead of frog. Firstly the types and terms of 
ottr doesn't match Adenines, in additon Adenine makes it possible to mainpulate and change the graph in it self,
like adding new tripels, will what we are looking for are a language that has pure functions. Lastly Adenine is 
imperative while we want a language that are more declarativ. 
\\ \\
The reason it still will be nice to have a language like frog that can be used in the template compared to the 
methodes mention over is that the functions becomes a part of the domain. In additon the methods mention over implies
that we have to add the inffered information before using template. Frog on the other side will offer the abilities to 
do this directly in the template. 
\\ \\
In additon an alternative approache to Frog which is not already meantion and which is not a part of semanitc web 
is using a scripting language to write the functions.
The benefits of making a whole new language like Frog for making functions instead of using a scripting language is 
that is that the types used in frog matches the types in OTTR (in additon to frog doing type checking) meaning that 
the we don't need to transelate types from one type system to another (from the scripting language to OTTR). This means 
that frog probably will be less error-prone than using a scripting language.
