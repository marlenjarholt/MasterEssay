%!TEX root = ../master.tex
\section{Frog}

\subsection{Motivation}
The use of OTTR templates proposes some benefits, such as better \emph{abstractions} and \emph{uniform modelling}, among other things. OTTR uses template patterns as an abstraction for low-level RDF triples and OWL axioms. Nonetheless, one may say that OTTR has the possibility to abstract even further. For instance, OTTR has no support for making URIs. Before using a template, one then has to make the URIs if they are none existing. Imagine that we have made a template that formally describes a person, with their social security number, name, age. Using the social security number in the URI is natural since this is uniquely identifying. Furthermore, we want to use the template on different sources, such as a tabular document and a CVS document. The template user has to construct the URIs differently in the different sources before using the template. OTTR being able to create the URIs in the template body would then further improve OTTR's benefit of abstraction. Additionally, creating URIs in the template body will benefit uniform modelling because it eases the \emph{maintenances}. Since changes in the URI structure only have to be done in the template and not in every source.

\para
Conceptualize that we want to store information about the weather. We want to use several sources for the data, perhaps several different CSV files. Most of the files use Celcius as their temperature scale, but a few of the files stores the temperatures in Fahrenheit. We, however, want to store all the temperature data in one standard temperature scale, namely Celcius. We have to either manually or by using a script convert Fahrenheit to Celcius before making instances from the data. However, this may be solved in the OTTR templates if it had been possible to do a simple operation on the Fahrenheit degrees. Doing the transformation manually from Fahrenheit to Celcius is time-consuming for big data sets. The second solution is still a solution, but this requires the template user to either know how to make a script for converting the degrees or use an exciting one. Using or making a script may interfere with one of the benefits of using OTTR, namely \emph{separation of design and content}. Separation of design and content in terms of OTTR means that it separates between the design of the knowledge base, the templates, and the knowledge base's content, the instance. Then the ontology experts can manage templates, and domain experts use familiar tools to create instances. The domain expert is not necessarily an expert on how to use scrips or make them. Ideally, the converting from Fahrenheit to Celcius should then be part of the design of the knowledge base. 

\para
To solve these issues, we propose a functional language that can make functions to manipulate the terms in OTTR, Frog. If needed, instances in a template body can use a Frog function to manipulate one or several arguments, for instance,  making a URI from a social security number or converting  Fahrenheit to Celcius. As previously mentioned, OTTR has a type system. Therefore, naturally, Frog will use the same type system, resulting in Frog being a typed language with parameter types and a return type.  The benefit of Frog being a types system is that we can perform we still can perform type checking in the templates. It is crucial to note that Frog only can manipulate terms and not change the graph; therefore, Frog will be a purely functional language. The idea is that Frog will have several language similarities to Scheme and other LISP languages and be written in RDF.

\para
Having a language like Frog also makes it possible to add infeed data. For instance, if we have the template ex-t:Person from earlier and we want to add a tripel to the expanded template containing the information about whether the person is of type adult (ex-p:Adult) or of type child (ex-p:Child). This is information that can be inferred from the age variable. As a result, we can make a new rdf-o:type with the person as the object and the result of the function ex-r:ageToLifeStage as the object. Where ex-r:ageToLifeStage is a Frog function that takes in an xsd:integer as an argument and returns a ottr:IRI. The ottr template below shows the potential use of the frog function in the ex-t:Person.

\begin{lstlisting}[frame=single]
    
ex-t:Person [
    ottr:IRI ?person,
    xsd:integer ?age,
    ? List<ottr:IRI> ?fathers,
    ? List<ottr:IRI> ?mothers,
    ? List<ottr:IRI> ?ancestors,
    List<xsd:String> ?names
    ] :: {
    cross | ottr:Triple(?person, ex-r:hasFather, ++?fathers),
    cross | ottr:Triple(?person, ex-r:hasMother, ++?mothers),
    ottr:Triple(?person, ex-r:hasAge, ?age),
    cross | ottr:Triple(?person, ex-r:hasName, ++?names),
    ottr:Triple(?person, ex-r:ancestor, ?ancestors),
    rdf-o:Type(?person, (ex-f:ageToLifeStage ?age))
}.
\end{lstlisting}

The expansion the two following two instances

\begin{lstlisting}[frame=single]
ottr:Triple(_:b, ex-r:hasFather, ex-p:Roger) .
ex-t:Person(ex-p:Sebastian, 22 , (ex-p:Thommas, _:b), none, 
(ex-p:Thommas, ex-p:Roger), ("Sebastian"@no, "Bastian"@en)).

ex-t:person(ex-p:Nina, 6, none, none ,none, ("Nina"@no))
\end{lstlisting}

will then be
\begin{lstlisting}[frame=single, language=turtle]
ex-p:Sebastian ex-r:hasFather ex-p:Thommas, [ ex-r:hasFather ex-p:Roger] ; 
                ex-r:hasAge  "22"^^xsd:int ; 
                ex-r:hasName  "Sebastian"@no, "Bastian"@en ;
                ex-r:ancestor (ex-p:Thommas ex-p:Roger);
                a ex-p:Adult.

ex-p:Nina ex-r:hasAge  "6"^^xsd:int ; 
          ex-r:hasName  "Nina"@no ;
          a ex-p:Child.
\end{lstlisting}

\subsection{Plans for Frog}
The plan is that frog is a language that is written in RDF. In addition to being a high-order functional language, 
with only pure functions. 
Frog will also have a type system, which we will come back to, and it should be clear form the definition of 
the function what the type of the different parameters are and the type of the return value. 
A frog function can only take in arguments and an return values that are a type from the OTTR type system, 
meaning that frog will have the same type system as OTTR and the same term system as OTTR.
The advantage of this is that frog can do type checking, since a function has a return value we can check that 
the type of the return value is of the same type that the argument in the instance needs to be.
Since frog is supposed to be a high-order language and will have the same type system as OTTR  
we need to add a new type to the OTTR type system, namely a function type that we need to give to every frog function. 
There is one exception to frog being high-order and that is that a function that is used directly in a 
template (like ex-f:ageToLifeStage in ex-t:Person) aren't allowed to return a function type. Due to addiong a new 
fnction type in the OTTR type system we also need to add terms that maches the new type. 

\subsubsection{Proposed syntax}
Frog's syntax has some properties that needs to be fulfilled: 
\begin{enumerate}
    \item The language shall be written in RDF 
    \item A named function should know its type. Where the type is a combination of the parameter types 
    and the return type of the function.
    \item A named function is not a function until the rdf:type is set as an Function
    \item The body of the function shall be build up by list, like the LISP languages
\end{enumerate}

\subsubsection{Proposed semantics}

\subsubsection{Evaluation}
The evaluation plan is to use a lazy evaluation approach. Lazy evaluation will be used in the functions themselves and decide when we should evaluate it in the OTTR template. The result is that lazy evaluation will ensure that the evaluation of a function only is performed when the function reaches a base template (like ottr:Tripple). Why lazy evaluation is a better approach than eager evaluation, in this case, is that OTTR does not force a user to use all variables in the template, even though OTTR throws a warning. Therefore, using lazy evaluation would mean that we only evaluate functions that OTTR uses. One of the disadvantages of lazy evaluation, as mention earlier, is I/O and error handling. Frog, however, are not supposed to have does feature. 

\para
Using lazy evaluation as an evaluation strategy will also add memorization. The reason why lazy evaluating is a good idea, in this case, is that when we have no way of knowing when calling an instance with a function as one of the arguments (if it is not a base template), how many times this value would end up in a base template. Lazy evaluation would then make sure that the function only is evaluated once for this function call and only if the value of the function ever is needed. Additionally, using a lazy evaluation approach will make it possible, as previously mentioned, to add features like streams. 

\subsubsection{Type checking in ottr}
Even though Frog will use lazy evaluation to evaluate a function call, it will check that the type returned by the function is compatible with the parameter type for that given argument. Meaning that calling a function that returns an xsd:string on an instance that expects an xsd:integer will throw an error. Checking that the type matches is necessary because a base template can have a more general type than the template.  This has to be done at this stage because the base template can be typed more generaly than what the template that makes the instances is, with general meaning that the type in the template of the instance is a subtype of the type in the base template. An excellent example of this is the base template ottr:Triple, which takes in 3 arguments that are ottr:Resources meaning that the arguments can be of any of the other types in the ottr type system since every type is a subtype of ottr:Resource, meaning that checking that the type returned by the function is compatible at this stage could result in a wrong answer. An Alternativ approach, where the type checking also is done when the function reaches a base template, would be to make a wrapper class that contains the function call and the expected type of the argument, and then evaluate that the type matches first when we need to use the function. The reason why this would not be the best approach is that we are not guaranteed that the function reaches a base template at some point, but OTTR throws a type error regardless. To check the typing at this stage will also mean that we will detect errors earlier.

\para
We also want it to be possible to write lambda-functions or anonym functions straight in to the ottr template. Since we want to check that 
the type returned by the function is compatible with the type that the template expects. This means that we have to be able to evaluate from 
the lambda function what type it will resolve to be. One methode to do this can be to use the same typing rules that are used in 
simply typed lambda calculus. The difference between simply typed lambda calculus and Frog lambda functions (for now) is that simply typed 
lambda calculus have the paramtertypes while Frog won't (because for now frog only set parameter types )  

\subsubsection{Validation of functions}
At some point, we need to validate the whole function. For the time being, we have only talked about validating that a functions return type matches OTTRs' expected argument type.  OTTR does some validations before expanding an instance. Such as checking that the syntax is correct. Naturally, Frog will also do some validation before OTTR starts to expand the instances. As OTTR, Frog will also check the syntax in advance. In addition, to validating that every used function in the function receives the correct arguments of the correct type. Meaning that if we have a function that uses a function, add, which takes in two terms of type xsd:integer. Then Frog will validate that the arguments given to add is two terms of type xsd:integer. Furthermore, Frog will also validate that the functions' return type is the same as the returned term.

\subsubsection{Div}
PLAN:
\begin{itemize}
    \item Skrive at man vil tilby de "klassikse" funksjonen map, filter og reduce
    \item Skrive om hvordan funksjonene skal lages, skal vi bruke en code genrator (ulempe: krever vedlikehold), en for hver type (ulempe: tid krevende. Finnes uendlige mange typer), generisk (kan fungere, da kan f.eks. add -funksjonen bli lagd for den mest generiske typen for tall)
\end{itemize}

\subsubsection{Termination}
There are several different ways to guarantee termination. As mention in the section about type theory, 
it is possible to make a type system for a programming language that guarantees termination. However, this often results in less expressive languages. 
Another approach is to make a set of base functions that can be used to build a new function, as described in the section about combinatory logic. 
Where the base functions are guaranteed to terminate. The reason why guaranteed termination would be a nice feature in Frog is that a valid OTTR template guarantees termination. 
Meaning that if Frog does not guarantee termination, OTTR templates that uses Frog functions can not guarantee it either

\subsection{Alternative approaches}
In this section, we will propose alternative approaches to Frog.  We group the approaches into two groups.  Firstly, we will consider how we can utilise different semantic technologies, namely SPARQL, OWL, and SWRL,  on the expanded OTTR template to yield the same result compared to Frog in some cases. Additionally, we will propose a way to solve some of the example issues presented in the motivation section using these semantic technologies.  Secondly, we will discuss two different languages for doing computation on RDF, Ripple and RDF, and how these may be an alternative to Frog. 

\subsubsection{SPARQL}
SPARQL is a query language over RDF with many similarities to SQL for relational databases, such as SELECT, WHERE, and GROUP BY. These clauses are also build up similarly in SPARQL and SQL.  Like SQL, SPARQL also offers clauses to delete data from the graph and insert data. Additionally, SPARQL also offers BIND, which allows us to assign values to a variable. Consequently, BIND makes it possible to make simple functions and bind the result of the function to a variable. Using a combination of an insert clause and BIND will then make it possible to add data to the graph from calculations.

\para
In the section about the motivation for making Frog, we described an example where we only wanted to store degrees in Celcius. However, some of the sources used Fahrenheit, resulting in a needed conversion. A possible solution to this problem, and similar ones, is to use SPARQL. Firstly we can make the triples using OTTR. Secondly, make a BIND that converts the existing Fahrenheit degrees to Celcius and use an insert clause to add the Celcius degree to the graph. Lastly, use a delete clause to delete all the triples which contain the degrees in Fahrenheit.

\para
Using SPARQL instead of a FROG function can yield the same result, meaning that SPARQL could be an alternative approach to FROG. However, in addition to SPARQL demanding more steps to get the same result, this technic does not preserve the benefit of abstraction as good as FROG. Having several steps may also result in more maintenance. In addition, one of FROG goals is that we only can manipulate the terms and not the whole graph. Using SPARQL, on the other hand, will manipulate the graph and not only the term. Consequently, using SPARQL as an alternative would not preserve the benefits of using FROG.   


\subsubsection{OWL}
Web Ontology Language (OWL) is an ontology language for the Semantic web, based on description logic. OWL provides us with classes, data properties, object properties, and instances. In addition, OWL defines ways to model classes, properties, and instances using logic. Among other things, OWL makes it feasible to model role restrictions. Role restrictions let us model classes as a set of objects that either only (universal restriction) have a role to a given set or has some (existential restriction) role to a given set.  With role descriptions and OWL, one can, for instance, express that a student takes some courses or that all plants only drink water. OWL also provides cardinality on roles, making it possible to express that all cats have four paws, for instance.

\para
Combined with reasoning, OWL can add infeed data to a graph. If we take the life stage example from the motivation section, one can make an ontology with OWL that states that all ex-p:Adult has some age greater than 17, and all ex-p:Child has some age less than 18—giving the persons the correct type.

\para 
To conclude, OWL can add inferred data to the graph. However, this is not the primary goal of Frog, which is to perform manipulation on terms, but more an additional feature. Moreover, using OWL has restrictions. We could not, for instance, use OWL to model that something with age over 17 has the ex-r:lifeStage ex-p:Adult. Meaning that OWL expects the data structured. Frog, on the other side, only works on the terms. Additionally, making function, or do computations on terms, is not possible with OWL. TODO: Legge til at det fjerner abstraction, og at ottr er "lagd" for å kunne lage axioms. 

\subsubsection{SWRL}
SWRL is a proposed language for the semantic web. SWRL can express rules and logic, combining OWL and a subset of Rule Markup language. In addition, SWRL also offers several functions that can we can use on different types, such as xsd:integer. However, SWRL does not allow us to make new functions only use predefined ones. Furthermore, an SWRL statement has two parts, a body and a head. The body is a set of conditions, while the head is the consequence of the conditions.

\para
Moreover, we can use SWRL to solve the life stage example and the Fahrenheit to Celcius example and similar problems. First, in the life stage example, we need to make two rules, one for the adult and one for the child. The first conditions are equal for both rules, namely that one has an age. In addition, the rule concluding in the rdf:type being ex-p:Child needs a condition stating that the age is less than 18, using the swrl:lessThan function. Concluding that the rdf:type is ex-p:Adult, on the other side, needs a second condition declaring that the age is greater than 17, using swrl:greaterThan. Likewise, SWRL can convert the Fahrenheit degree to Celcius, where we, in the conclusion, could combine several math functions offered by SWRL to convert the degree.

\para
\begin{itemize}
    \item Skrive om hvordan SWRL lar oss gjøre mye av det vi er ute etter
    \item Vi kan ikke gjøre utregninger på noe som trenges under OTTR templatet
    \item Alle kalkulasjoner må gjøres etter at instansen er expanded 
    \item maintenance og abstraction
    \item ottr har ikke noe rule language, selv om frog ikke er et rule language kan man bruke det til å lage regler. 
\end{itemize}

\subsubsection{Ripper}
Ripple is a functional, stack-based query language that allows us to both make queries and functions that we can use on RDF. Ripples interface has two different statements: making queries and making what they call commands or directives. Combining the command, define, and querying can make functions.   

\para
Ripple has numerous similarities to Frog, such as being functional, using lazy evaluation and using a nested list structure. Compared to the semantic technologies, making a function call using a Ripple function inside an OTTR template may be possible. As a result, making necessary calculations before expanding the instances, such as making a URI, is possible. However, using Ripple as an alternative may yield one problem: different typing and term systems. Meaning that, for instance, checking that a return type matches the expected type of the argument may be difficult. These problems may be complicated to solve for the OTTR specific types like the LUB and list types.    

\subsubsection{Adenine}
Another alternative approach that is similar to Ripper is Adenine. Adenine is a language written for project Haystack to more effectively make and manipulate RDF-data, meaning that it can change the graph directly with, e.g. adding new tripels. Adenine is an imperative language that has a syntax that can resemble a combination of Python and lisp. 

\para
Like Ripper, one of the problems for using Adenine as an alternative approach is that OTTR and Adenine do not utilise the same type or term system. Additionally, Adenine does not change or manipulate terms but whole graphs. Consequently, Adenine needs, similar to the semantic technologies, to work on the expanded OTTR instances. Working on the expanded instances has mainly two consequences. Firstly, making functions that return a value that OTTR needs to expand the instances, like making URIs, is impossible. Secondly, this may not improve   TODO: hvordan dette kan "ødlegge" for abstractions

\subsubsection{Summarisation}
\begin{itemize}
    \item Snakke om de to hoved approchene
    \item Forklare hvorfor Adenine og Ripper ikke fungerer, mtp at det vi bruker Frog i OTTR ikke er rdf men termer
    \item 
\end{itemize}

\subsubsection{OLD STUFF}
The reason it still will be nice to have a language like frog that can be used in the template compared to the 
methodes mention over is that the functions becomes a part of the domain. In additon the methods mention over implies
that we have to add the inffered information before using template. Frog on the other side will offer the abilities to 
do this directly in the template. 
\\ \\
In additon an alternative approache to Frog which is not already meantion and which is not a part of semanitc web 
is using a scripting language to write the functions.
The benefits of making a whole new language like Frog for making functions instead of using a scripting language is 
that is that the types used in frog matches the types in OTTR (in additon to frog doing type checking) meaning that 
the we don't need to transelate types from one type system to another (from the scripting language to OTTR). This means 
that frog probably will be less error-prone than using a scripting language.

\subsection{Summary}